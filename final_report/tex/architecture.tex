\documentclass[../document.tex]{subfiles}

\begin{document}


\section{Architecture}
\label{architecture}
\subsection{Introduction}
This chapter gives an overview of the architectural structure of the system, including quality attributes, and architectural styles, constraints, tactics and views. This is the architecture we plan on following, and any changes made during the implementation will be documented and found in \appendixfullref{retired_architecture}. The sensors and the rasberry pi were already connected together by Altran so we will not write the architecture between the sensors and the Raspberry Pi. The Raspberry Pi and the database will use the REST style to communicate and is implemented by one of us. The database will act as a client. The connection between the database and the user interface will follow Altrans framework for their database/GUI connection which uses the REST style.

\subsection{Quality Attributes}
\label{quality_attributes}
The quality metrics can be found in \subsubfullref{subsubsec:quality_metrics}

\subsubsection{Functionality}
The system consists of multiple sensor devices, a central hub, and one or more client devices. The sensors gather data from an environment, such as temperature, light level, or sound, and move it to a central hub. A client device collects sensor data from the central hub, and visualizes the data in a grand manner.

\subsubsection{Performance}
The system is a real time system, and changes in the environment is registered at the client within five seconds. Also, all transfer links in the system has sufficient throughput to avoid delay or lost packages.

\subsubsection{Scalability}
The system is scaleable to a large degree, and supports adding many sensor devices and central hubs.

\subsubsection{Modifiability of Components}
The software is easy to alter or configure, to ease system modifications such as moving or removing components, or relocating the system.

\subsubsection{Portability of Components}
The program code for both the central hub and the sensors is portable, making the system hardware replaceable. This is to ensure that a customer is not tied to any specific supplier. The data should be stored in a database.

\subsection{Architectural Styles}
\subsubsection{Representational State Transfer (REST)}
We plan to make a system with a RESTful similarity between the databaser and the central hub. The architectural style REST focus on how components, connectors and data elements works together within a distributed hypermedia system. REST will accomplish that by having a set of architectural constraints that applies to all modules and their relations. The individual module is not concerned in REST architecture, meaning that the implementation is not that important. The architectural constraints applied by REST can be found under the next subsection architectural constraints. REST is used as a description of the wanted web architecture. We use it to find and identify problems in our system architecture and make sure our system should follow the constraint we find to be more important. As in any software architecture the components, the connectors and the data elements are used to find what architectural properties are most needed in the system. Our components, connectors and data elements are as listed:

\begin{table}[H]
	\caption{Identified REST elements}
	\begin{tabularx}{\textwidth}{|X|X|}
		\hline
		\textbf{Components}		& The sensors, the central hub, the database and the UI.  \\ \hline
		\textbf{Connectors}		& The database who ask on-demand for the data the central hub receives from the sensors.  \\ \hline
		\textbf{Data elements}	& The information sent from the sensors through every component in the system until it reaches  the visualization.  \\ \hline
	\end{tabularx}
\end{table}

We are using the REST style as guidelines, and therefore it may be some inconsistencies between our system and a RESTful system. 

\subsection{Architectural Constraints}
REST has some formal constraints we have to follow. If the system does not follow these constraints the system does not have RESTful architecture. They are all written with an interest to our system and architecture.

\subsubsection{Client-Server}
The central hub will act as a server, and a database as the client. All the data is stored in a database that may be run externally. The central hub will not be worrying about the UI or any kind of user interference or status. This makes the central hub more scalable and it can be developed or changed without the database knowing if the interface between them are altered or not. 

\subsubsection{Stateless}
When the database asks for a data update from the central hub, all the information needed for the central hub to do what is requested is in the request sent from the database. All the states of the database is only for the database to see. The central hub should not be concerned with which state the database is in. The database have 4 different states which are state 1: send request, state 2: pull data, state 3: store data 4: send data.

\subsubsection{Cacheable}
The client in our system is the database, which means our client will store all the data it receives. 

\subsubsection{Layered System}
Our system might not be layered, so the database will most likely know for certain that it is connected to the central hub. This is not usually how the REST architecture acts, however we are only having a RESTful system as a framework. 

\subsubsection{Code on Demand}
This is the only architectural constraint that is optional with the REST architecture, and we have decided it is not going to be a concern with our system. However, the formal description of this constraint is: Code on demand allows clients to improve its flexibility by temporarily letting the servers extend or customize the functionality of a client. This is done by transferring executable code.

\subsubsection{Uniform Interface}
This constraint is used to make the architecture simpler and helps every individual part of the system to evolve independently. The uniform interface is split into four different guidelines.

\paragraph{Identification of Resources} \ \\
The resources in a REST architecture is identified in the requests and are separate from the representations that the client receives. 

\paragraph{Manipulation of Resources through These Representations} \ \\
The client should be able to modify the representation of a resource it receives. As an example the client could be able to calculate maximum, minimum and average of data from each sensor. 

\paragraph{Self-Descriptive Messages} \ \\
All the client requests and server responses are messages, and in a RESTful application these messages are expected to be self-descriptive. This means that each message should contain all the information needed to process this message. Moreover, the interaction between requests is stateless, responses explicitly indicate cacheability and standard methods and media types are used to indicate semantics and exchange information. Each message can have a body and metadata.

\paragraph{Hypermedia As the Engine of Application State (A.K.A. HATEOAS)}
The principle that hypermedia is the engine of application state means that a REST client does not need to have any understanding of how to interact with any application or server beyond a generic understanding of hypermedia. In other words, except for simple entry points in the application, a client does not make any state transitions without hypermedia dynamically provided by the server. 

\subsection{Architectural Tactics}
\subsubsection{Performance}
To achieve the performance attribute we will let the database receive information from the sensors every 5 seconds. 

\subsubsection{Scalability}
As mentioned earlier, the server will not be worrying about any kind of user interference, status or UI. This makes the server more scalable.

\subsubsection{Modifiability of Components}
To ensure that the system can be easily changed we will use the abstract common services tactic. To abstract common services is when services that provide similar services is implemented once in a general module instead of many times in slightly different but more specific modules. When the common services are abstracted, modifications to them will need to be made to only one module instead of in each module where the services are used. This tactic also supports the prevention of ripple effects because the modifications to the modules that uses these services will not impact other modules.

\subsubsection{Portability of Components}
Because the program code for both the central hub and the sensors is portable, the customer is not tied to a specific supplier. This improves the portability of the components.

\subsection{Stakeholders and Concerns}
\begin{table}[H]
	\caption{Stakeholders}
	\begin{tabularx}{\textwidth}{|X|X|}
		\hline
		\textbf{Stakeholders}	& \textbf{Descriptions} \\ \hline
		End user				& The end user is the future clients who will use our system.  \\ \hline
		Developers				& The developer are us in group 10 and our job is to develop the product and document the project.  \\ \hline
		Customer				& The customer is Stig Lau representing Altran AS. He will specify the product to be developed.  \\ \hline
		Adviser					& The adviser is Mohsen Anvaari. His job is to act as our guide during the project.  \\ \hline
		Course staff			& The course staff for subject TDT4290 will provide information and prestudy for the course.  \\ \hline
		Hardware suppliers		& The hardware suppliers are the makers for the components used in this project.  \\ \hline
	\end{tabularx}
\end{table}

\paragraph{End User:} The end user is the future clients who will use the system. They can watch the visualization form the data gathered from a room on a web page or similar. 

\paragraph{Developers:} The developers in this project is us in group 10. Our job is to plan, implement and test the wanted product. We will start with planning, and then write requirement and architecture documents. When the documentation is done, we will implement the system in Scrum-style sprints. During implementation, we will follow our test plan until the customer is satisfied and the product is finished. We might add test results, changes and issues we had along the way and finish the report and deliver it to the customer.

\paragraph{Customer:} The customer is Stig Lau representing Altran AS. He specify the product to be developed, and will meet with the developers to agree on details and clear out discrepancies around the product implementation. He has the final word when it comes to what functions the system should and should not have. He is also the developers guide on how the sensors and central hub supplied by Altran works, and what can be done with them.

\paragraph{Adviser:} The groups adviser is Mohsen Anvaari. He will give feedback and guide the developers on all areas. This will be done by giving feedback and help us create a good documentation, and help us with any issues we might have that does not concern the client.

\paragraph{Course Staff:} The course staff for subject TDT4290 will be a part of the prestudy as they hold lectures needed for the course, and guidelines and tips for the project. 

\paragraph{Hardware Suppliers:} The hardware suppliers in this project are the developers of the components used in this project. They are delivering all of the parts needed for the sensors and the central hub.

\subsection{Architectural Views}
\subsubsection{Introduction}
In this section we will show the different views of our architecture. We will follow the structure of the 4+1 View Model of Software Architecture. We chose this view model because it allows us to handle the functional and nonfunctional requirements separately, and also address the different concerns of the various stakeholders separately. The client and the database are the same in our system, however in the views we seperate them to see how the client side of the database works.


\subsubsection{Logical View}		
The logical view is primarily concerned with the functional requirements. In other words, it is concerned with what the system should provide in terms of services to its end-users. Our logic view uses a class diagram to demonstrate the logical interaction between the database, the gui, the gatherer, the server, and the sensors. 


\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Architecture/LogicalView.png}
	\caption{Logical View}
\end{figure}

\subsubsection{Development View}
The development view, also known as the implementation view,  presents the system from a programmers perspective and is concerned with software management. Our development view shows the relationships between importing and exporting information from and to the database. It shows that the client stores the information from the sensors in the database and that the visualiser pulls the information from the database.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Architecture/DevelopmentView.png}
	\caption{Development View}
\end{figure}

\subsubsection{Process View}
The process view considers the dynamic aspects of the system. It explains the system processes and how they communicate, and focuses on the runtime behavior of the system. We use an activity diagram to present how the different parts in the system are connected. The parts include the checkboxes that decides which elements the user wants to see. 

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Architecture/ProcessviewNew.png}
	\caption{Process View}
\end{figure}

\subsubsection{Physical View}
The physical view, also known as the deployment view, is concerned with the topology of software components on the physical layer, as well as the physical connections between these components. In other words, it depicts the system from a system engineers point of view. The sensors are all somehow connected to the REST server, which gives information about the sensors to the database through the REST client. If the sensors for some reason are not used then the database gets random information from mock-up data. The user interface gets information from the database.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Architecture/SystemDiagram.png}
	\caption{System Diagram}
\end{figure}

\subsubsection{Scenarios and Use Cases}
\paragraph{Scenarios} \ \\
The scenarios view, also known as the use case view, describe sequences of interactions between objects, and between processes. They are used to identify architectural elements and to illustrate and validate the architecture design. They also serve as a starting point for tests of an architecture prototype.

\begin{table}[H]
	\caption{Scenario P1}
	\begin{tabularx}{\textwidth}{|X|X|}
		\hline
		ID					& P1 \\ \hline
		Source				& System \\ \hline
		Stimulus			& The light gets turned off \\ \hline
		Environment			& Runtime \\ \hline
		Artifact			& Light sensors \\ \hline
		Response			& Update the new info, and add it to the database \\ \hline
		Response Measure	& Time \newline Should be less than 30 seconds \newline Accuracy \newline The data should be correctly represented
		\\ \hline
	\end{tabularx}
\end{table}

\begin{table}[H]
	\caption{Scenario P2}
	\begin{tabularx}{\textwidth}{|X|X|}
		\hline
		ID					& P2 \\ \hline
		Source				& System \\ \hline
		Stimulus			& The temperature gets higher \\ \hline
		Environment			& Runtime \\ \hline
		Artifact			& Temperature sensors \\ \hline
		Response			& The animation in the visualiser should start after it pulls new data from the database \\ \hline
		Response Measure	& Time\newline Should be less than 30 seconds \newline Accuracy \newline The data should be correctly represented
		\\ \hline
	\end{tabularx}
\end{table}

\begin{table}[H]
	\caption{Scenario P3}
	\begin{tabularx}{\textwidth}{|X|X|}
		\hline
		ID					& P3 \\ \hline
		Source				& System \\ \hline
		Stimulus			& The pressure changes \\ \hline
		Environment			& Runtime \\ \hline
		Artifact			& Pressure sensors \\ \hline
		Response			& The animation in the visualiser should start after it pulls new data from the database \\ \hline
		Response Measure	& Time\newline Should be less than 30 seconds \newline Accuracy \newline The data should be correctly represented
		\\ \hline
	\end{tabularx}
\end{table}

\begin{table}[H]
	\caption{Scenario P4}
	\begin{tabularx}{\textwidth}{|X|X|}
		\hline
		ID					& P4 \\ \hline
		Source				& System \\ \hline
		Stimulus			& The humidity changes \\ \hline
		Environment			& Runtime \\ \hline
		Artifact			& Humidity sensors \\ \hline
		Response			& The animation in the visualiser should start after it pulls new data from the database \\ \hline
		Response Measure	& Time\newline Should be less than 30 seconds \newline Accuracy \newline The data should be correctly represented
		\\ \hline
	\end{tabularx}
\end{table}

\begin{table}[H]
	\caption{Scenario P5}
	\begin{tabularx}{\textwidth}{|X|X|}
		\hline
		ID					& P5 \\ \hline
		Source				& System \\ \hline
		Stimulus			& User uncheck an element  \\ \hline
		Environment			& Runtime \\ \hline
		Artifact			& GUI \\ \hline
		Response			& The presentation of that specific element will be hidden \\ \hline
		Response Measure	& Time\newline Should be instant \newline Accuracy \newline The data should be correctly hidden
		\\ \hline
	\end{tabularx}
\end{table}

\paragraph{Use Cases} \ \\
The use cases shows two ways a user can interact with the system. The first shows how a user can uncheck elements it does not want to see on the screen and second shows how the user can check them back if the user wants to see them again.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Architecture/usecaseUncheck.png}
	\caption{Use Case Uncheck}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Architecture/usecaseCheck.png}
	\caption{Use Case Check}
\end{figure}

\subsubsection{Sprint 4 Scenarios and Use Cases}

With sprint 4, we have introduced some new use-case scenarios into the system, but the architecture remains the same as it was before. The new use-case scenarios are listed below, in \tableref{scenario6} and \tableref{scenario7}. The use case diagram for sprint 4 is in the \figfullref{usecasesprint4}
\begin{table}[H]
\caption{Scenario P6}
\label{scenario6}
\begin{tabularx}{\textwidth}{|X|X|}
\hline	
ID
&P6
\\ \hline Source
&System
\\ \hline Stimulus
&The link budget changes
\\ \hline Environment
&Runtime
\\ \hline Artifact
&Link budget sensor
\\ \hline Response
&The animation of sensor movement will happen after the next pull from the database.
\\ \hline Response Measure
&Time \newline
Should be less than 30 seconds \newline
Accuracy \newline
The sensor should be correctly placed on the screen according to the link budget
\\ \hline
\end{tabularx}
\end{table}

\begin{table}[H]
\caption{Scenario P7}
\label{scenario7}
\begin{tabularx}{\textwidth}{|X|X|}
\hline	
ID
&P7
\\ \hline Source
&System
\\ \hline Stimulus
&The administrator changes the calibration
\\ \hline Environment
&Configuration time
\\ \hline Artifact
&Constant.txt
\\ \hline Response
&The sensor movement will be scaled by the Constant.txt
\\ \hline Response Measure
&Accuracy \newline
The scaling of the data will change upon the next boot up of the system, and this should be correctly reflected by the animation.
\\ \hline
\end{tabularx}
\end{table}


\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Architecture/useCasesprint4.png}
	\caption{Use Case Sprint 4}
	\label{usecasesprint4}
\end{figure}

\end{document}
