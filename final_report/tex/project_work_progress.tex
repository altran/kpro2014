\documentclass[../document.tex]{subfiles}

\begin{document}

\section{Project Work Progress}

\subsection{Introduction}
During the length of the project there have been many changes. These changes were mostly introduced by the customer, while the \gls{REST} were decisions made by the group. We have changed the system as a whole three times, with all of the changes listed in this section, and therefore the documentation has changed substantially along with the plans we made in the beginning. This section will list our work progress through the project.

\subsection{Overview of Changes to the System}
\subsubsection{Smart Room}
After the first meeting with the customer, the group held several brainstorming sessions, to think of ideas where the sensors could be used. The most interesting ideas thought of are included in the preliminary study document. Our first main idea for implementation and the one that we started the planning for was a system that behaved like a ‘smart room’. We wanted to make a system that could be able to keep the temperature, lighting, humidity, noise, pressure and tracking stable by collecting data from the sensors and control various devices in the room, such as air conditioning, curtains and humidifiers. Our prototype of the system would most likely not control the devices in the room, but it would do the gathering of the data and the calculations needed to be able to control the devices correctly. Furthermore, we wanted the system to be able to identify a device showing abnormal data, store data from sensors over time and show the data that is currently stored at request.

\subsubsection{TableView, HistoryView and MapView}
Before we started implementing the smart room idea, we had a customer meeting. The customer explained to us that we were too specific, and suggested that we document our ideas without implementing them. The customer asked for a visualisation that shows the data from the sensors in an interesting fashion, making it necessary to change our plans. Through an extra brainstorming session we developed new ideas for visualisation, including them in our preliminary study document. These ideas were presented and discussed with the customer, and we agreed on a new idea. The idea was of a system that takes data from the sensors and visualizes it in different views. Switching between the views it is possible to show the data in different ways. Initially we had three views planned: The \emph{table view} would show sensors and sensor data in a table format with checkboxes on the side to show or hide columns.  This view was a minimal implementation. It should take little time to implement and it should allow us to verify the correctness of other views and the system backend. The \emph{map view}, would visualize the sensor data in a kind of map, where the placement of the sensor would indicate where the sensor was placed relative to the central hub. The \emph{history view} was a version of the map view that would play back past sensor data. The playback time interval is set by selecting starting time and end time from a list. In order to navigate from one view to another, there will be buttons placed below the visualisation in the screen area, in addition to toggle buttons on the right hand side of the visualization where one can decide what information that should be shown. 

Out of the views listed in the preliminary study, we chose to work with the simple image manipulation in a grid. This visualisation choice was weighed across all of the choices and was chosen for its simplicity and the ability to display data without too much clutter. Furthermore, we took the term “grid” in a very abstract fashion. We defined the grid as a space the sensors occupy. Since we were yet unsure about the hardware capabilities of the sensors, and especially their ability to triangulate position, we needed to make a very abstract grid. We also needed to make the visualisation as simple as possible, since we were not working directly with hardware.

When we actually received the hardware, we did extensive testing on it and it proved inefficient in determining precise locations. Furthermore, as we only had one central hub, we only had one “plane” to work with, the x plane, or the distance to the sensor. But since the accuracy of the sensor position was lacking with the sensors themselves, we opted to instead animate the sensors as planets, orbiting around the central hub. This is an indication that this central hub is receiving data from these sensors but does not now accurately where they are located. The movement also helps bring life to a rather dull and static animation.

In the latter parts of the project the customer expressed their wish to have a more direct position by using the link budget. As previously mentioned and as shown at a demonstration with the customer at the same meeting the link budget is lacking in accuracy. Nonetheless, the customer felt that position should be implemented. Without another central hub we need to create mock up data. This in the end forces us to have two different prototypes - one “live” prototype that is completely modular and mock up data free, and one mock up prototype, where we use fake data injected into the database and changed by hand to showcase the possibility of more hardware. 

\subsubsection{MapView}
After implementing the table view and starting on the map view, the customer stated that the table view was not important. The customer wanted us to remove both the table view and the history view, and requested several changes to the map view. As the table view was only made for testing purposes, there was no need to navigate between it and the map view, and we removed the button for view navigation. Because of the requested changes in the map view, another brainstorm session was needed. After presenting and discussing the ideas with the customer, we ended up with a mapview where the sensors are represented by circular objects orbiting around the central hub. The sensor objects consist of one inner circle which shows the lighting, one outer circle which shows the temperature, one raindrop on the lower right of the outer circle which represents humidity, and one balloon (upside-down raindrop) on the upper right side of the outer circle which represents pressure. The circles gradually change color when the lighting or temperature changes. The raindrop and the balloon fill up with more humidity or pressure, and are emptied when there is less humidity or pressure.

\subsubsection{Client}
The system backend has always involved the client module. The client is responsible for receiving sensor data from the central hub, storing received data it in a database, and sending stored data to the visualiser. Due to requirements put forward by the customer, the client design needed to be changed twice during the project. The initial plan was to use an \gls{SQL} database, hosted at the \gls{NTNU} login server. One of the group members had knowledge of this system, making implementation an easy affair. The first working prototype was finished after a week, fully integrated with the initial map view, but using mock-up data. However, at the sprint review, the customer strongly recommended to the group not to use an \gls{SQL} database. The reason for this being that the sensor data to be stored is not relational. As an alternative, the customer suggested that we use a \gls{JSON} file as a database, and store it in the Google docs. Later he also suggested we may store \gls{JSON} using the \gls{JSON}-based hosting service Cloudant. The group opted for Cloudant, after a few days of investigating both opportunities. Time was also invested in finding out and deciding how to access Cloudant data, and work began on an implementation. It took a total of two weeks to get a working client that was partly finished. At this point the group received an email from the customer, revealing that \gls{Altran} were working a very similar project. This project involved modules duplicating the functionality of the client. It was also requested that the group use the same \gls{JSON} format as \gls{Altran} for sensor data, and that the group should push the sensor data gathered to Altran’s database. \gls{Altran} supplied their full code for inspiration. From this it was deduced that the client module was not an important module to the customer, and the decision was made to scrap it. A new client module was designed that would function as a thin wrapper around Altran’s database. A main motivating factor behind the decision was that by using Altran’s database, future change requirements would be avoided. The new client prototype was mostly ready at the end of the second sprint, and was integrated into the system early in the third sprint.

\subsubsection{Other Changes to the System}
Initially, we were not certain if we would actually would get the hardware required for the project, namely the sensors and the raspberry pi. We started on the sprints later than we planned since we needed a backup plan in case we did not get the hardware. Therefore we created two different versions of the system, one with the sensors and one with the use of android phones. After it was confirmed that we would get the hardware, we moved away from the idea of using a smartphone and started to implement our system in regards to the hardware. The architecture was changed to follow the \gls{REST}-style for the connection between the hardware and the database. 

Initially we designed a system that had a separate component that connected to the gateway and received the sensor data, processed it and pushed it in the database. At a later stage in the developing process we decided that we had to change this. If the sensors were behind a network with firewall or behind a router which allowed communication only using the port 80, then this would not have worked. The initial design used a \gls{Java} based client which connected to the gateway through a \gls{HTTP} GET request and received the data in a \gls{JSON}-like format. Since the data did not respect the \gls{JSON} protocol 100\%, we had to process the data with a special handler which took into consideration these details and after parsing it we we pushed it into a CouchDB database. In order to push the data in the database, we also had to convert it again from a \gls{Java} object to \gls{JSON} using a library from Google called GSON. 

For the problem regarding the fact that the gateway is behind a firewall, we found a solution: install the component straight on the Raspberry Pi. But the solution was not feasible since the board had a lightweight operating system which did not support \gls{Java} so we decided to take another approach. We used a few shell scripts to get the data from the sensors and push it raw into an \gls{Altran} web server which parsed the data and introduced it into the database.

\subsection{Changes in the Documentation}

\subsubsection{Requirements}
In the first cast for the requirements, based on the smart room idea, we decided that the requirements should be divided into three levels. The first level would be the hardware level from the sensors to the software, the second level would be the visualiser, and the third level would manipulate the environment. The entire requirements document can be seen in \appendixfullref{sec:requirements_cast_1}. We have also planned other functions such as the ad-hoc connection model, which we have also later discarded. 

The second cast for the requirements was made after we had found out that the third level was not necessary. In the second cast for the requirements we changed our focus to increase the visualiser function. We kept most of our user interaction from the first requirement, and removed the third level completely. The entire requirements document can be seen in \appendixfullref{requirements_cast_2}

The third cast for the requirements was the final version of the requirements document, as seen in \sectionfullref{requirements}. The customer wished for as little user interaction as possible. The customer also did not want a table view or a history view. We have kept the table view internally, but have focused our attention more on the integration and visualisation of the system.

\subsubsection{Architecture}
Our initial architecture was created for the smart room system. The first draft was never completed and is therefore somewhat empty and some places are more descriptions than completed subsections. The first draft of the architecture can be seen in \appendixfullref{retired_architecture}. At first we wanted to use the Model-View-Controller pattern, but the customer expressed disagreements and instead wanted us to use the \gls{REST}-style. He also had some comments to the quality attributes. Therefore we started to write a new architecture document according to the \gls{REST}-style. We changed the quality attributes to go with a RESTful architecture including the comments the customer had given us. After some time the customer said he did not want a smart room, he only wanted ideas and a small visualization, therefore we needed to cut down on the architecture, and create new use cases and scenarios and an updated physical view. However most of the architecture was the same as we mostly focused on the \gls{REST}-style, and not the implementation, so we did the changes in the final document. We also added the logical view, the development view and the process view to fit the tableview, historyview and mapview visualisation. Later in the project the customer wanted the visualization to become only one view, the map view, therefore we had to change some of the model views to make them match the new visualization. The old models,views and scenarios can be found under \appendixfullref{retierd_architectural_views}. The architecture have also changed the way the central hub and the database where connected. At the start we wanted to have a data collector that pulled data from the central hub to the database, this is now done directly within the database.

\subsubsection{Test plan}
We started making a test plan as soon as the first requirement documentation was done. We did not, however, create an entire test plan. Rather than that, we had only made a checklist for what tests will be required. After that we put more time into designing the system and less time into testing the system. This was a good work balancing choice, since the requirements changed many times and with the requirement changes the test plan changed as well. The test plan in its current state was made after finalising the requirements document.

\subsection{Changes in the Planning}

\subsubsection{Gantt}
When we first started the project we did extensive planning to accommodate the entire group in a healthy work schedule. A part of this was the Gantt diagram that can be seen in project planning. However, there is quite a big difference in the work progress and the Gantt diagram. The main difference is in the agile development; we had planned for three sprints of elleven days each, but in reality did four sprints of varying lengths. The first sprint lasted for three weeks, the second sprint lasted for two weeks, the third sprint lasted for ten days, while the fourth and last sprint lasted for two weeks. Change in schedule is to be expected when using agile methodology, however, it is difficult to execute when time is a limited resource. Therefore, the main reason that we strayed far away from the Gantt diagram is the changes implemented within the length of the project. 

If we were aware of some notions before, such as the database implementation, we could have shortened our work process significantly. Therefore, miscommunication also played a part in us not being able to stay on the same schedule.

\subsubsection{Schedule of Results}
The schedule of results, which can be found in the introduction of this document, has changed as well. The reasons for this change are much the same as for the Gantt diagram not being followed. However, the two main milestones, which is the pre-delivery to the external examiner, as well as the presentation have been followed. As these had to do with the actual course deadlines and not with the project milestones set by us they were of greater priority.

\end{document}